

const Data = [
    {
        type: 'renderTitle',
        content: 'EventLoop 事件循环'
    },
    {
        type: 'renderHtml',
        content: `
            <text>首先，需要了解JS是单线程的，JS通过事件循环的方式来实现异步回调</text>
            <codeBlock>
                <code>关于进程、线程</code>
                <ul>
                    <li>1. 进程代表CPU所能处理的单个任务，是CPU资源分配的最小单位</li>
                    <li>2. 线程是CPU调度的最小单位，一个进程中可以有多个线程</li>
                </ul>
            </codeBlock>
            <text>而浏览器是多进程的。每一个tab页，就是一个独立的进程。</text>
            <codeBlock>
                <code> 浏览器包含哪些线程：</code>
                <ul>
                    <li>1. 主进程 ： 用于协调其它子进程、浏览器界面显示、</li>
                    <li>2. 第三方插件进程： 仅当使用插件时才创建</li>
                    <li>3. GPU进程： 用于3D绘制</li>
                    <li>4. 渲染进程： 负责页面渲染、执行脚本、事件处理【浏览器内核】</li>
                </ul>
            </codeBlock>
            <text>我们需要了解的是渲染进程，这是前端接触最多也是最重要的浏览器进程，也就是我们常说的浏览器内核。</text>
            <text>一个进程可以包含多个线程。</text>
            <codeBlock>
                <code>渲染进程包含哪些线程： </code>
                <ul>
                    <li>1. GUI渲染线程 - 页面渲染、布局和绘制 
                    【和JS引擎渲染互斥 - 防止渲染结果不可预期】
                    【回流和重绘会引发该线程】</li>
                    <li>
                    2. JS引擎线程  - 解析执行js脚本
                    【单线程】
                    </li>
                    <li>3. 事件触发线程  - 控制事件循环，满足触发条件后，将事件放入js引擎所在执行队列</li>
                    <li>4. 定时触发器线程 - setInterval & setTimeout 
                    【定时任务由定时线程处理】
                    【计时完毕，通知事件触发线程】</li>
                    <li>5. 异步http请求线程 - ajax请求
                    【请求完毕，若有回调，通知事件触发线程】
                    </li>
                </ul>
            </codeBlock>
            <text>同步任务都在JS引擎线程上执行，也就是我们常说的执行栈。</text>
            <text>事件触发线程管理着一个任务队列，异步任务被触发后，会将回调函数放入任务队列。当执行栈中的同步任务执行完毕后，系统会读取任务队列，将任务队列中的回调函数放至执行栈中，达到异步执行回调函数的目的</text>
            <text>Eg：当执行一个setTimeout代码时，首先setTimeout本身是一个同步函数，JS引擎线程执行到这里时，会通知定时器线程，间隔一定时间后，触发一个回调函数。该回调函数会被放入事件线程管理的任务队列中，当JS引擎线程所在的执行栈空闲了后，就会去任务队列中取出该回调函数执行。</text>
            <codeBlock>
                <code>什么是宏任务，什么是微任务</code>
                <ul>
                    <li>
                        1. 每次在执行栈中执行的代码就是一次宏任务。
                        <p>【注意每次从任务队列取出一个回调函数放入执行栈执行就是一次宏任务】</p>
                        <p>【GUI渲染进程的工作时间是前一次宏任务执行完毕，下一次宏任务未开始执行之前， 也就是两个宏任务之间】 </p>
                    </li>
                    <li>
                        2. 微任务就是在每一次宏任务结束后都会立马被执行的任务，执行时机在渲染前
                        【promise、nextTick属于微任务】
                    </li>
                </ul>
            </codeBlock>
        `
    },
]

export default Data